import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from tkinter import PanedWindow
import threading
import imaplib
import email
from email.header import decode_header
import time
import os
import json
from datetime import datetime, timedelta, timezone
import logging
import re
import html
import base64
import secrets
import sys
import traceback
import hashlib

# ====================== é…ç½®æ—¥å¿—ç³»ç»Ÿ ======================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("email_monitor.log", encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("EmailMonitor")

# ====================== å°è¯•å¯¼å…¥éŸ³é¢‘åº“ ======================
try:
    import winsound
    AUDIO_AVAILABLE = True
except ImportError:
    logger.warning("Windowså£°éŸ³åº“ä¸å¯ç”¨ï¼Œå°†ç¦ç”¨å£°éŸ³æé†’")
    AUDIO_AVAILABLE = False

# ====================== è¿æ¥çŠ¶æ€æšä¸¾ ======================
class ConnectionState:
    DISCONNECTED = "æ–­å¼€"
    CONNECTING = "è¿æ¥ä¸­"
    CONNECTED = "å·²è¿æ¥"
    RECONNECTING = "é‡è¿ä¸­"
    ERROR = "é”™è¯¯"

# ====================== å·¥å…·ç±» ======================

class SimpleEncryptionHelper:
    """ç®€åŒ–çš„åŠ å¯†åŠ©æ‰‹"""
    def __init__(self):
        self.key_file = "email_config.key"
        self.key = self._load_or_create_key()

    def _load_or_create_key(self):
        """åŠ è½½æˆ–åˆ›å»ºå¯†é’¥"""
        if os.path.exists(self.key_file):
            try:
                with open(self.key_file, 'rb') as f:
                    return f.read()
            except:
                pass
        # åˆ›å»ºæ–°å¯†é’¥
        key = secrets.token_bytes(32)
        with open(self.key_file, 'wb') as f:
            f.write(key)
        return key

    def encrypt(self, data):
        """åŠ å¯†æ•°æ®"""
        try:
            encoded = base64.b64encode(data.encode())
            result = bytearray()
            key_len = len(self.key)
            for i, byte in enumerate(encoded):
                result.append(byte ^ self.key[i % key_len])
            return base64.b64encode(result).decode()
        except:
            return base64.b64encode(data.encode()).decode()

    def decrypt(self, encrypted_data):
        """è§£å¯†æ•°æ®"""
        try:
            decoded = base64.b64decode(encrypted_data.encode())
            result = bytearray()
            key_len = len(self.key)
            for i, byte in enumerate(decoded):
                result.append(byte ^ self.key[i % key_len])
            return base64.b64decode(result).decode()
        except:
            try:
                return base64.b64decode(encrypted_data.encode()).decode()
            except:
                return ""

class TimeChecker:
    """æ”¹è¿›çš„æ—¶é—´æ£€æŸ¥å™¨"""
    @staticmethod
    def parse_email_date(date_str: str) -> datetime:
        """è§£æé‚®ä»¶å¤´ä¸­çš„Dateå­—æ®µ"""
        if not date_str:
            return None
        try:
            date_str = date_str.strip()
            formats = [
                '%a, %d %b %Y %H:%M:%S %z',
                '%d %b %Y %H:%M:%S %z',
                '%a, %d %b %Y %H:%M:%S %Z',
                '%Y-%m-%d %H:%M:%S',
                '%Y-%m-%dT%H:%M:%S',
                '%Y/%m/%d %H:%M:%S',
            ]
            for fmt in formats:
                try:
                    dt = datetime.strptime(date_str, fmt)
                    if dt.tzinfo is None:
                        dt = dt.replace(tzinfo=timezone.utc)
                    return dt
                except ValueError:
                    continue
            try:
                from email.utils import parsedate_to_datetime
                return parsedate_to_datetime(date_str)
            except Exception as parse_err:
                logger.warning(f"ä½¿ç”¨parsedate_to_datetimeè§£æå¤±è´¥: {parse_err}")
        except Exception as e:
            logger.error(f"è§£æé‚®ä»¶æ—¶é—´å¤±è´¥: {date_str}, é”™è¯¯: {e}")
        return None

    @staticmethod
    def extract_best_time_from_body(body: str, email_date: datetime = None) -> tuple:
        """ä»é‚®ä»¶æ­£æ–‡ä¸­æå–æœ€ä½³å‚è€ƒæ—¶é—´"""
        if not body:
            return None
        time_patterns = [
            (r'\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:?\d{2})?\b', '%Y-%m-%dT%H:%M:%S', "ISOæ ¼å¼"),
            (r'\b\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}\b', '%Y-%m-%d %H:%M:%S', "æ ‡å‡†æ—¥æœŸæ—¶é—´"),
            (r'\b\d{4}/\d{2}/\d{2}\s+\d{2}:\d{2}:\d{2}\b', '%Y/%m/%d %H:%M:%S', "æ–œæ æ—¥æœŸæ—¶é—´"),
            (r'\b\d{2}:\d{2}:\d{2}\b', '%H:%M:%S', "çº¯æ—¶é—´"),
            (r'\b\d{2}:\d{2}\b', '%H:%M', "çº¯æ—¶é—´(æ— ç§’)"),
        ]
        beijing_tz = timezone(timedelta(hours=8))
        now = datetime.now(beijing_tz)
        found_times = []
        for pattern, fmt, description in time_patterns:
            matches = re.finditer(pattern, body)
            for match in matches:
                time_str = match.group()
                try:
                    if fmt in ['%H:%M:%S', '%H:%M']:
                        if email_date:
                            date_part = email_date.strftime('%Y-%m-%d')
                            full_time_str = f"{date_part} {time_str}"
                            full_fmt = f"%Y-%m-%d {fmt}"
                        else:
                            date_part = now.strftime('%Y-%m-%d')
                            full_time_str = f"{date_part} {time_str}"
                            full_fmt = f"%Y-%m-%d {fmt}"
                    else:
                        full_time_str = time_str
                        full_fmt = fmt
                    parsed_time = datetime.strptime(full_time_str, full_fmt)
                    if parsed_time.tzinfo is None:
                        parsed_time = parsed_time.replace(tzinfo=beijing_tz)
                    if email_date:
                        time_diff = abs((parsed_time - email_date).total_seconds())
                        if time_diff < 3600:
                            weight = 2
                        else:
                            weight = 1
                    else:
                        weight = 1
                    found_times.append((parsed_time, time_str, description, weight))
                except ValueError:
                    continue
        if not found_times:
            return None
        def get_score(item):
            time_obj, _, _, weight = item
            time_diff = abs((now - time_obj).total_seconds())
            return weight * 1000 - time_diff
        best_time = max(found_times, key=get_score)
        return (best_time[0], best_time[1])

    @staticmethod
    def is_old_email(email_date: datetime, body: str, threshold_minutes: int = 30) -> tuple:
        """æ£€æŸ¥é‚®ä»¶æ˜¯å¦è¿‡æœŸï¼Œè¿”å›(æ˜¯å¦è¿‡æœŸ, åŸå› , å‚è€ƒæ—¶é—´)"""
        try:
            beijing_tz = timezone(timedelta(hours=8))
            now = datetime.now(beijing_tz)
            threshold = timedelta(minutes=threshold_minutes)
            if email_date:
                if email_date.tzinfo is None:
                    email_date = email_date.replace(tzinfo=timezone.utc)
                try:
                    email_date_beijing = email_date.astimezone(beijing_tz)
                except:
                    email_date_beijing = email_date.replace(tzinfo=beijing_tz)
                time_diff = now - email_date_beijing
                if time_diff > threshold:
                    return (True, f"é‚®ä»¶å‘é€æ—¶é—´å·²è¿‡ {time_diff.total_seconds() / 60:.1f} åˆ†é’Ÿ", email_date_beijing)
                else:
                    return (False, f"é‚®ä»¶å‘é€æ—¶é—´åœ¨ {threshold_minutes} åˆ†é’Ÿå†…", email_date_beijing)
            body_time_result = TimeChecker.extract_best_time_from_body(body, email_date)
            if body_time_result:
                body_time, time_str = body_time_result
                time_diff = now - body_time
                if time_diff > threshold:
                    return (True, f"æ­£æ–‡æ—¶é—´ '{time_str}' å·²è¿‡ {time_diff.total_seconds() / 60:.1f} åˆ†é’Ÿ", body_time)
                else:
                    return (False, f"æ­£æ–‡æ—¶é—´åœ¨ {threshold_minutes} åˆ†é’Ÿå†…", body_time)
            return (False, "æœªæ‰¾åˆ°æ—¶é—´ä¿¡æ¯", None)
        except Exception as e:
            logger.error(f"æ—¶é—´æ£€æŸ¥å¤±è´¥: {e}")
            return (False, f"æ—¶é—´æ£€æŸ¥å¤±è´¥: {e}", None)

def html_to_text(html_content):
    """å°†HTMLè½¬æ¢ä¸ºçº¯æ–‡æœ¬"""
    if not html_content:
        return ""
    try:
        html_content = re.sub(r'<script[^>]*>.*?</script>', '', html_content, flags=re.DOTALL | re.IGNORECASE)
        html_content = re.sub(r'<style[^>]*>.*?</style>', '', html_content, flags=re.DOTALL | re.IGNORECASE)
        html_content = re.sub(r'<br\s*/?>', '\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'</(p|div|tr|td|th)[^>]*>', '\n', html_content, flags=re.IGNORECASE)
        html_content = re.sub(r'<[^>]+>', '', html_content)
        html_content = html.unescape(html_content)
        html_content = re.sub(r'\n+', '\n', html_content)
        html_content = re.sub(r'[ \t]+', ' ', html_content)
        html_content = re.sub(r'\n\s+\n', '\n\n', html_content)
        return html_content.strip()
    except Exception as e:
        logger.error(f"HTMLè½¬æ¢å¤±è´¥: {e}")
        return re.sub(r'<[^>]+>', '', html_content)

class EmailDetailDialog:
    """é‚®ä»¶è¯¦æƒ…å¯¹è¯æ¡†"""
    def __init__(self, parent, email_data):
        self.parent = parent
        self.email_data = email_data
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("é‚®ä»¶è¯¦æƒ…")
        self.dialog.geometry("900x700")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        self.dialog.protocol("WM_DELETE_WINDOW", self.on_close)
        self.create_widgets()
        self.load_email_data()
        self.center_dialog()

    def create_widgets(self):
        """åˆ›å»ºå¯¹è¯æ¡†ç»„ä»¶"""
        main_frame = ttk.Frame(self.dialog, padding=15)
        main_frame.pack(fill=tk.BOTH, expand=True)
        title_frame = ttk.Frame(main_frame)
        title_frame.pack(fill=tk.X, pady=(0, 15))
        ttk.Label(title_frame, text="ğŸ“§ é‚®ä»¶è¯¦æƒ…", font=('Arial', 14, 'bold')).pack(side=tk.LEFT)
        ttk.Button(title_frame, text="å…³é—­", command=self.on_close, width=10).pack(side=tk.RIGHT)
        info_frame = ttk.LabelFrame(main_frame, text="åŸºæœ¬ä¿¡æ¯", padding=15)
        info_frame.pack(fill=tk.X, pady=(0, 15))
        row = 0
        info_labels = [
            ("å‘ä»¶äºº:", "from", "æœªçŸ¥"),
            ("æ”¶ä»¶äºº:", "to", "æœªçŸ¥"),
            ("æ—¶é—´:", "date", "æœªçŸ¥"),
            ("ä¸»é¢˜:", "subject", "æ— ä¸»é¢˜"),
            ("åŒ¹é…å…³é”®å­—:", "keywords", "æ— "),
            ("å¤„ç†çŠ¶æ€:", "status", "æœªçŸ¥")
        ]
        for label_text, key, default in info_labels:
            ttk.Label(info_frame, text=label_text, font=('Arial', 10, 'bold')).grid(
                row=row, column=0, sticky=tk.W, pady=5)
            label = ttk.Label(info_frame, text="", font=('Arial', 10))
            label.grid(row=row, column=1, sticky=tk.W, pady=5, padx=10)
            setattr(self, f"{key}_label", label)
            row += 1
        body_frame = ttk.LabelFrame(main_frame, text="é‚®ä»¶æ­£æ–‡", padding=10)
        body_frame.pack(fill=tk.BOTH, expand=True)
        self.body_text = scrolledtext.ScrolledText(body_frame, wrap=tk.WORD, font=('Arial', 10), height=20, width=80)
        self.body_text.pack(fill=tk.BOTH, expand=True)
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(15, 0))
        ttk.Button(button_frame, text="ğŸ“‹ å¤åˆ¶æ­£æ–‡", command=self.copy_body, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="ğŸ’¾ ä¿å­˜åˆ°æ–‡ä»¶", command=self.save_to_file, width=15).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="âœ… æ ‡è®°ä¸ºå·²å¤„ç†", command=self.mark_as_processed, width=15).pack(side=tk.LEFT, padx=5)

    def load_email_data(self):
        """åŠ è½½é‚®ä»¶æ•°æ®"""
        try:
            for key in ['from', 'to', 'date', 'subject', 'keywords', 'status']:
                label = getattr(self, f"{key}_label")
                value = self.email_data.get(key, "æœªçŸ¥")
                label.config(text=value)
            status_colors = {"æ­£å¸¸è­¦æŠ¥": "red", "å·²å¿½ç•¥": "blue", "æ—¶é—´è¿‡æœŸ": "orange", "å·²å¤„ç†": "green"}
            status = self.email_data.get('status', 'æœªçŸ¥')
            if status in status_colors:
                self.status_label.config(foreground=status_colors[status])
            body = self.email_data.get('body', 'æ— æ­£æ–‡')
            body_text = html_to_text(body)
            self.body_text.insert('1.0', body_text)
            self.body_text.config(state='disabled')
        except Exception as e:
            logger.error(f"åŠ è½½é‚®ä»¶æ•°æ®å¤±è´¥: {e}")
            self.body_text.insert('1.0', f"åŠ è½½é‚®ä»¶æ•°æ®å¤±è´¥: {e}")

    def copy_body(self):
        """å¤åˆ¶æ­£æ–‡å†…å®¹"""
        try:
            body = self.body_text.get('1.0', 'end-1c')
            self.dialog.clipboard_clear()
            self.dialog.clipboard_append(body)
            messagebox.showinfo("æç¤º", "æ­£æ–‡å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"å¤åˆ¶å¤±è´¥: {e}")

    def save_to_file(self):
        """ä¿å­˜é‚®ä»¶åˆ°æ–‡ä»¶"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            subject_clean = re.sub(r'[<>:"/\\|?*]', '', self.email_data.get('subject', 'æ— ä¸»é¢˜'))[:50].strip() or "æ— ä¸»é¢˜"
            filename = f"é‚®ä»¶_{timestamp}_{subject_clean}.txt"
            with open(filename, 'w', encoding='utf-8') as f:
                f.write("=" * 80 + "\né‚®ä»¶è¯¦æƒ…\n" + "=" * 80 + "\n\n")
                for key, label in [("å‘ä»¶äºº", "from"), ("æ”¶ä»¶äºº", "to"), ("æ—¶é—´", "date"), ("ä¸»é¢˜", "subject"),
                                   ("åŒ¹é…å…³é”®å­—", "keywords"), ("çŠ¶æ€", "status")]:
                    f.write(f"{key}: {self.email_data.get(label, 'æœªçŸ¥')}\n")
                f.write("\n" + "=" * 80 + "\næ­£æ–‡å†…å®¹:\n" + "=" * 80 + "\n\n")
                f.write(html_to_text(self.email_data.get('body', 'æ— æ­£æ–‡')))
            messagebox.showinfo("ä¿å­˜æˆåŠŸ", f"é‚®ä»¶å·²ä¿å­˜åˆ°æ–‡ä»¶:\n{filename}")
        except Exception as e:
            messagebox.showerror("ä¿å­˜å¤±è´¥", f"ä¿å­˜æ–‡ä»¶å¤±è´¥: {e}")

    def mark_as_processed(self):
        """æ ‡è®°ä¸ºå·²å¤„ç†"""
        try:
            self.status_label.config(text="å·²å¤„ç†", foreground="green")
            self.email_data['status'] = "å·²å¤„ç†"
            if hasattr(self.parent, 'update_email_status'):
                email_id = self.email_data.get('id')
                if email_id:
                    self.parent.update_email_status(email_id, "å·²å¤„ç†")
            messagebox.showinfo("æç¤º", "é‚®ä»¶å·²æ ‡è®°ä¸ºå·²å¤„ç†")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"æ ‡è®°å¤±è´¥: {e}")

    def center_dialog(self):
        """å±…ä¸­æ˜¾ç¤ºå¯¹è¯æ¡†"""
        self.dialog.update_idletasks()
        width = self.dialog.winfo_width()
        height = self.dialog.winfo_height()
        x = (self.dialog.winfo_screenwidth() // 2) - (width // 2)
        y = (self.dialog.winfo_screenheight() // 2) - (height // 2)
        self.dialog.geometry(f'{width}x{height}+{x}+{y}')

    def on_close(self):
        """å…³é—­å¯¹è¯æ¡†"""
        self.dialog.grab_release()
        self.dialog.destroy()

class LoginFrame(ttk.Frame):
    """ç™»å½•ç•Œé¢"""
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        self.encryption_helper = SimpleEncryptionHelper()
        self.server_var = tk.StringVar(value="imap.exmail.qq.com")
        self.port_var = tk.StringVar(value="993")
        self.username_var = tk.StringVar()
        self.password_var = tk.StringVar()
        self.keyword_file_var = tk.StringVar()
        self.ignore_keyword_file_var = tk.StringVar()
        self.sound_file_var = tk.StringVar()
        self.status_var = tk.StringVar(value="å°±ç»ª")
        self.create_widgets()
        self.load_config()

    def create_widgets(self):
        """åˆ›å»ºç•Œé¢ç»„ä»¶"""
        main_frame = ttk.Frame(self, padding=30)
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        ttk.Label(main_frame, text="ä¼ä¸šé‚®ç®±ç›‘æ§ç³»ç»Ÿ", font=('Arial', 18, 'bold'), foreground="#2C3E50").grid(
            row=0, column=0, columnspan=4, pady=(0, 30))
        config_items = [
            ("IMAPæœåŠ¡å™¨:", self.server_var, 30, None),
            ("ç«¯å£:", self.port_var, 10, None),
            ("é‚®ç®±è´¦å·:", self.username_var, 30, None),
            ("é‚®ç®±å¯†ç :", self.password_var, 30, "*"),
            ("ç›‘æ§å…³é”®å­—æ–‡ä»¶:", self.keyword_file_var, 25, None),
            ("å¿½ç•¥å…³é”®å­—æ–‡ä»¶:", self.ignore_keyword_file_var, 25, None),
            ("è‡ªå®šä¹‰å‘Šè­¦å£°éŸ³:", self.sound_file_var, 25, None)
        ]
        for i, (label_text, var, width, show) in enumerate(config_items, 1):
            ttk.Label(main_frame, text=label_text).grid(row=i, column=0, sticky=tk.W, pady=8)
            if label_text == "ç«¯å£:":
                frame = ttk.Frame(main_frame)
                frame.grid(row=i, column=1, sticky=(tk.W, tk.E), pady=8, padx=5)
                ttk.Entry(frame, textvariable=var, width=width).pack(side=tk.LEFT)
                continue
            frame = ttk.Frame(main_frame)
            frame.grid(row=i, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=8, padx=5)
            frame.columnconfigure(0, weight=1)
            entry = ttk.Entry(frame, textvariable=var, show=show)
            entry.grid(row=0, column=0, sticky=(tk.W, tk.E))
            if label_text in ["ç›‘æ§å…³é”®å­—æ–‡ä»¶:", "å¿½ç•¥å…³é”®å­—æ–‡ä»¶:", "è‡ªå®šä¹‰å‘Šè­¦å£°éŸ³:"]:
                browse_func = getattr(self, f"browse_{'keyword' if 'å…³é”®å­—' in label_text else 'sound'}_file")
                ttk.Button(frame, text="æµè§ˆ", command=browse_func, width=8).grid(row=0, column=1, padx=5)
        ttk.Button(main_frame, text="æµ‹è¯•å£°éŸ³", command=self.test_sound, width=12).grid(row=7, column=3, padx=5)
        note_text = """ä½¿ç”¨è¯´æ˜ï¼š
1. ç›‘æ§å…³é”®å­—æ–‡ä»¶ï¼šæ¯è¡Œä¸€ä¸ªå…³é”®å­—
2. å¿½ç•¥å…³é”®å­—æ–‡ä»¶ï¼šæ¯è¡Œæ ¼å¼ä¸º'æ ‡é¢˜å…³é”®å­—:æ­£æ–‡å…³é”®å­—1,æ­£æ–‡å…³é”®å­—2,...'
3. è‡ªå®šä¹‰å‘Šè­¦å£°éŸ³ï¼šé€‰æ‹©.wavæ ¼å¼çš„å£°éŸ³æ–‡ä»¶ï¼ˆå¯é€‰ï¼‰
4. å…³é”®å­—æ–‡ä»¶ä¿®æ”¹åä¼šè‡ªåŠ¨é‡æ–°åŠ è½½"""
        ttk.Label(main_frame, text=note_text, foreground="#666").grid(row=8, column=0, columnspan=4, sticky=tk.W, pady=15)
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=9, column=0, columnspan=4, pady=20)
        ttk.Button(button_frame, text="ğŸ”— æµ‹è¯•è¿æ¥", command=self.test_connection, width=15).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="ğŸš€ å¼€å§‹ç›‘æ§", command=self.login_and_start, width=15).pack(side=tk.LEFT, padx=10)
        ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN, padding=10, anchor=tk.W).grid(
            row=10, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(10, 0))

    def browse_keyword_file(self):
        """æµè§ˆç›‘æ§å…³é”®å­—æ–‡ä»¶"""
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©ç›‘æ§å…³é”®å­—æ–‡ä»¶",
            filetypes=[("æ–‡æœ¬æ–‡ä»¶", "*.txt"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        if filename:
            self.keyword_file_var.set(filename)

    def browse_ignore_keyword_file(self):
        """æµè§ˆå¿½ç•¥å…³é”®å­—æ–‡ä»¶"""
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©å¿½ç•¥å…³é”®å­—æ–‡ä»¶",
            filetypes=[("æ–‡æœ¬æ–‡ä»¶", "*.txt"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        if filename:
            self.ignore_keyword_file_var.set(filename)

    def browse_sound_file(self):
        """æµè§ˆè‡ªå®šä¹‰å£°éŸ³æ–‡ä»¶"""
        filename = filedialog.askopenfilename(
            title="é€‰æ‹©å‘Šè­¦å£°éŸ³æ–‡ä»¶",
            filetypes=[("WAVå£°éŸ³æ–‡ä»¶", "*.wav"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        if filename:
            self.sound_file_var.set(filename)

    def load_config(self):
        """åŠ è½½é…ç½®"""
        try:
            if os.path.exists("email_config.json"):
                with open("email_config.json", "r", encoding="utf-8") as f:
                    config = json.load(f)
                    self.server_var.set(config.get("server", "imap.exmail.qq.com"))
                    self.port_var.set(config.get("port", "993"))
                    self.username_var.set(config.get("username", ""))
                    self.keyword_file_var.set(config.get("keyword_file", ""))
                    self.ignore_keyword_file_var.set(config.get("ignore_keyword_file", ""))
                    self.sound_file_var.set(config.get("sound_file", ""))
                    encrypted_password = config.get("password", "")
                    if encrypted_password:
                        decrypted_password = self.encryption_helper.decrypt(encrypted_password)
                        self.password_var.set(decrypted_password)
                self.status_var.set("âœ… é…ç½®åŠ è½½æˆåŠŸ")
                logger.info("é…ç½®åŠ è½½æˆåŠŸ")
        except Exception as e:
            logger.error(f"åŠ è½½é…ç½®å¤±è´¥: {e}")

    def save_config(self):
        """ä¿å­˜é…ç½®"""
        try:
            encrypted_password = self.encryption_helper.encrypt(self.password_var.get())
            config = {
                "server": self.server_var.get(),
                "port": self.port_var.get(),
                "username": self.username_var.get(),
                "keyword_file": self.keyword_file_var.get(),
                "ignore_keyword_file": self.ignore_keyword_file_var.get(),
                "sound_file": self.sound_file_var.get(),
                "password": encrypted_password,
                "last_updated": datetime.now().isoformat()
            }
            with open("email_config.json", "w", encoding="utf-8") as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
            logger.info("é…ç½®ä¿å­˜æˆåŠŸ")
            return True
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
            return False

    def test_connection(self):
        """æµ‹è¯•è¿æ¥"""
        errors = self.validate_config()
        if errors:
            messagebox.showerror("é…ç½®é”™è¯¯", "\n".join(errors))
            return
        self.status_var.set("ğŸ”„ æ­£åœ¨æµ‹è¯•è¿æ¥...")
        thread = threading.Thread(target=self._test_connection_thread, daemon=True)
        thread.start()

    def _test_connection_thread(self):
        """æµ‹è¯•è¿æ¥çº¿ç¨‹"""
        mail = None
        try:
            server = self.server_var.get()
            port = int(self.port_var.get())
            username = self.username_var.get()
            password = self.password_var.get()
            logger.info(f"æµ‹è¯•è¿æ¥åˆ° {server}:{port}")
            mail = imaplib.IMAP4_SSL(server, port, timeout=30)
            mail.login(username, password)
            status, _ = mail.select('INBOX')
            if status == 'OK':
                self.after(0, lambda: self.status_var.set("âœ… è¿æ¥æµ‹è¯•æˆåŠŸ!"))
                logger.info("è¿æ¥æµ‹è¯•æˆåŠŸ")
            else:
                self.after(0, lambda: self.status_var.set("âŒ æ— æ³•è®¿é—®æ”¶ä»¶ç®±"))
        except Exception as e:
            error_msg = str(e)[:100]
            self.after(0, lambda: self.status_var.set(f"âŒ è¿æ¥å¤±è´¥: {error_msg}"))
            logger.error(f"è¿æ¥æµ‹è¯•å¤±è´¥: {e}")
        finally:
            if mail:
                try:
                    mail.logout()
                except:
                    pass

    def test_sound(self):
        """æµ‹è¯•å£°éŸ³"""
        if not AUDIO_AVAILABLE:
            messagebox.showwarning("è­¦å‘Š", "éŸ³é¢‘åŠŸèƒ½ä¸å¯ç”¨")
            return
        sound_file = self.sound_file_var.get()
        if sound_file and os.path.exists(sound_file):
            try:
                for _ in range(2):
                    winsound.PlaySound(sound_file, winsound.SND_FILENAME | winsound.SND_ASYNC)
                    time.sleep(0.5)
                self.status_var.set("ğŸ”Š æ’­æ”¾è‡ªå®šä¹‰å£°éŸ³")
                logger.info(f"æ’­æ”¾è‡ªå®šä¹‰å£°éŸ³: {sound_file}")
            except Exception as e:
                self.status_var.set(f"âŒ æ’­æ”¾å¤±è´¥: {e}")
                logger.error(f"æ’­æ”¾è‡ªå®šä¹‰å£°éŸ³å¤±è´¥: {e}")
        else:
            try:
                winsound.MessageBeep()
                self.status_var.set("ğŸ”Š æ’­æ”¾ç³»ç»Ÿæç¤ºéŸ³")
                logger.info("æ’­æ”¾ç³»ç»Ÿæç¤ºéŸ³")
            except Exception as e:
                self.status_var.set(f"âŒ æ’­æ”¾å¤±è´¥: {e}")
                logger.error(f"æ’­æ”¾ç³»ç»Ÿå£°éŸ³å¤±è´¥: {e}")

    def validate_config(self):
        """éªŒè¯é…ç½®"""
        errors = []
        if not self.server_var.get().strip():
            errors.append("è¯·è¾“å…¥æœåŠ¡å™¨åœ°å€")
        port = self.port_var.get().strip()
        if not port or not port.isdigit() or not (1 <= int(port) <= 65535):
            errors.append("è¯·è¾“å…¥æœ‰æ•ˆçš„ç«¯å£å· (1-65535)")
        if '@' not in self.username_var.get().strip():
            errors.append("è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±è´¦å·")
        if len(self.password_var.get().strip()) < 6:
            errors.append("å¯†ç é•¿åº¦è‡³å°‘6ä½")
        keyword_file = self.keyword_file_var.get().strip()
        if not keyword_file or not os.path.exists(keyword_file):
            errors.append("ç›‘æ§å…³é”®å­—æ–‡ä»¶ä¸å­˜åœ¨")
        ignore_file = self.ignore_keyword_file_var.get().strip()
        if ignore_file and not os.path.exists(ignore_file):
            errors.append("å¿½ç•¥å…³é”®å­—æ–‡ä»¶ä¸å­˜åœ¨")
        sound_file = self.sound_file_var.get().strip()
        if sound_file and not os.path.exists(sound_file):
            errors.append("è‡ªå®šä¹‰å£°éŸ³æ–‡ä»¶ä¸å­˜åœ¨")
        return errors

    def load_keywords(self):
        """åŠ è½½ç›‘æ§å…³é”®å­—"""
        filename = self.keyword_file_var.get()
        keywords = set()
        try:
            with open(filename, "r", encoding="utf-8") as f:
                for line in f:
                    keyword = line.strip()
                    if keyword:
                        keywords.add(keyword)
            logger.info(f"åŠ è½½ {len(keywords)} ä¸ªç›‘æ§å…³é”®å­—")
            return keywords
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"åŠ è½½ç›‘æ§å…³é”®å­—å¤±è´¥: {e}")
            return set()

    def load_ignore_keywords(self):
        """åŠ è½½å¿½ç•¥å…³é”®å­—"""
        filename = self.ignore_keyword_file_var.get()
        ignore_keywords = []
        if not filename or not os.path.exists(filename):
            return ignore_keywords
        try:
            with open(filename, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or ':' not in line:
                        continue
                    parts = line.split(':', 1)
                    subject_keyword = parts[0].strip()
                    body_keywords = [kw.strip() for kw in parts[1].strip().split(',') if kw.strip()]
                    if subject_keyword and body_keywords:
                        ignore_keywords.append({
                            'subject': subject_keyword,
                            'body_keywords': body_keywords
                        })
            logger.info(f"åŠ è½½ {len(ignore_keywords)} ä¸ªå¿½ç•¥å…³é”®å­—é…å¯¹")
            return ignore_keywords
        except Exception as e:
            messagebox.showwarning("è­¦å‘Š", f"åŠ è½½å¿½ç•¥å…³é”®å­—å¤±è´¥: {e}")
            return []

    def login_and_start(self):
        """ç™»å½•å¹¶å¼€å§‹ç›‘æ§"""
        errors = self.validate_config()
        if errors:
            messagebox.showerror("é…ç½®é”™è¯¯", "\n".join(errors))
            return
        if not self.save_config():
            return
        keywords = self.load_keywords()
        if not keywords:
            messagebox.showwarning("è­¦å‘Š", "ç›‘æ§å…³é”®å­—æ–‡ä»¶ä¸ºç©º!")
            return
        ignore_keywords = self.load_ignore_keywords()
        sound_file = self.sound_file_var.get().strip()
        if sound_file and not os.path.exists(sound_file):
            sound_file = ""
        self.controller.show_main_frame(
            server=self.server_var.get(),
            port=int(self.port_var.get()),
            username=self.username_var.get(),
            password=self.password_var.get(),
            keywords=keywords,
            ignore_keywords=ignore_keywords,
            keyword_file=self.keyword_file_var.get(),
            ignore_keyword_file=self.ignore_keyword_file_var.get(),
            sound_file=sound_file
        )

class FileWatcher:
    """æ–‡ä»¶ç›‘è§†å™¨ï¼Œå®æ—¶ç›‘æ§æ–‡ä»¶å˜åŒ–"""
    def __init__(self, file_path, callback, check_interval=5):
        self.file_path = file_path
        self.callback = callback
        self.check_interval = check_interval
        self.last_mtime = 0
        self.last_hash = ""
        self.watching = False
        self.thread = None
        self.lock = threading.Lock()

    def start(self):
        """å¼€å§‹ç›‘è§†æ–‡ä»¶"""
        if self.watching:
            return
        self.watching = True
        self.thread = threading.Thread(target=self._watch_loop, daemon=True)
        self.thread.start()

    def stop(self):
        """åœæ­¢ç›‘è§†æ–‡ä»¶"""
        with self.lock:
            self.watching = False
        if self.thread and self.thread.is_alive():
            self.thread.join(timeout=3.0)

    def _watch_loop(self):
        """ç›‘è§†å¾ªç¯"""
        while True:
            with self.lock:
                if not self.watching:
                    break
            try:
                if os.path.exists(self.file_path):
                    current_mtime = os.path.getmtime(self.file_path)
                    try:
                        with open(self.file_path, 'rb') as f:
                            content = f.read()
                            current_hash = hashlib.md5(content).hexdigest()
                    except Exception as e:
                        logger.error(f"è¯»å–æ–‡ä»¶å¤±è´¥: {e}")
                        current_hash = ""
                    if current_mtime != self.last_mtime or current_hash != self.last_hash:
                        self.last_mtime = current_mtime
                        self.last_hash = current_hash
                        self.callback()
                else:
                    self.last_mtime = 0
                    self.last_hash = ""
            except Exception as e:
                logger.error(f"æ–‡ä»¶ç›‘è§†é”™è¯¯: {e}")
            for _ in range(self.check_interval * 10):
                with self.lock:
                    if not self.watching:
                        break
                time.sleep(0.1)

class ConnectionManager:
    """è¿æ¥ç®¡ç†å™¨ï¼Œè´Ÿè´£ç»´æŠ¤IMAPè¿æ¥"""
    def __init__(self, server, port, username, password, scan_interval=300):
        self.server = server
        self.port = port
        self.username = username
        self.password = password
        self.scan_interval = scan_interval
        self.mail = None
        self.connection_state = ConnectionState.DISCONNECTED
        self.last_heartbeat = None
        self.last_activity = None
        self.consecutive_failures = 0
        self.lock = threading.Lock()
        
        # å¿ƒè·³é—´éš” = æ‰«æé—´éš”çš„1/3ï¼Œæœ€å°60ç§’ï¼Œæœ€å¤§300ç§’
        self.heartbeat_interval = self._calculate_heartbeat_interval(scan_interval)
        logger.info(f"æ‰«æé—´éš”{scan_interval//60}åˆ†é’Ÿï¼Œè®¾ç½®å¿ƒè·³é—´éš”: {self.heartbeat_interval}ç§’")
    
    def _calculate_heartbeat_interval(self, scan_interval):
        """è®¡ç®—å¿ƒè·³é—´éš”ï¼šæ‰«æé—´éš”çš„1/3"""
        heartbeat = scan_interval // 3
        
        # è®¾ç½®åˆç†çš„èŒƒå›´ï¼šæœ€å°60ç§’ï¼Œæœ€å¤§300ç§’ï¼ˆ5åˆ†é’Ÿï¼‰
        if heartbeat < 60:
            return 60
        elif heartbeat > 300:
            return 300
        return heartbeat
    
    def update_scan_interval(self, new_scan_interval):
        """æ›´æ–°æ‰«æé—´éš”å¹¶é‡æ–°è®¡ç®—å¿ƒè·³é—´éš”"""
        self.scan_interval = new_scan_interval
        old_interval = self.heartbeat_interval
        self.heartbeat_interval = self._calculate_heartbeat_interval(new_scan_interval)
        if old_interval != self.heartbeat_interval:
            logger.info(f"å¿ƒè·³é—´éš”æ›´æ–°: {old_interval} â†’ {self.heartbeat_interval}ç§’")
    
    def connect(self):
        """å»ºç«‹è¿æ¥"""
        with self.lock:
            if self.mail:
                try:
                    self.mail.logout()
                except:
                    pass
                self.mail = None
            
            self.connection_state = ConnectionState.CONNECTING
            try:
                self.mail = imaplib.IMAP4_SSL(self.server, self.port, timeout=30)
                self.mail.login(self.username, self.password)
                self.mail.select('INBOX')
                self.connection_state = ConnectionState.CONNECTED
                self.last_heartbeat = datetime.now()
                self.last_activity = datetime.now()
                self.consecutive_failures = 0
                return True
            except Exception as e:
                self.connection_state = ConnectionState.ERROR
                self.consecutive_failures += 1
                raise Exception(f"è¿æ¥å¤±è´¥: {e}")
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        with self.lock:
            if self.mail:
                try:
                    self.mail.logout()
                except Exception as e:
                    logger.debug(f"ç™»å‡ºå¤±è´¥: {e}")
                self.mail = None
            self.connection_state = ConnectionState.DISCONNECTED
            logger.debug("è¿æ¥å·²æ–­å¼€")
    
    def reconnect(self):
        """é‡æ–°è¿æ¥"""
        with self.lock:
            self.connection_state = ConnectionState.RECONNECTING
            logger.debug("å¼€å§‹é‡æ–°è¿æ¥...")
            try:
                # å…ˆæ–­å¼€ç°æœ‰è¿æ¥
                if self.mail:
                    try:
                        self.mail.logout()
                    except:
                        pass
                    self.mail = None
                
                # å»ºç«‹æ–°è¿æ¥
                self.mail = imaplib.IMAP4_SSL(self.server, self.port, timeout=30)
                self.mail.login(self.username, self.password)
                self.mail.select('INBOX')
                self.connection_state = ConnectionState.CONNECTED
                self.last_heartbeat = datetime.now()
                self.last_activity = datetime.now()
                self.consecutive_failures = 0
                logger.debug("é‡æ–°è¿æ¥æˆåŠŸ")
                return True
            except Exception as e:
                self.connection_state = ConnectionState.ERROR
                self.consecutive_failures += 1
                logger.error(f"é‡æ–°è¿æ¥å¤±è´¥: {e}")
                raise Exception(f"é‡æ–°è¿æ¥å¤±è´¥: {e}")
    
    def should_send_heartbeat(self):
        """åˆ¤æ–­æ˜¯å¦éœ€è¦å‘é€å¿ƒè·³"""
        if not self.last_heartbeat:
            return True
        
        # è®¡ç®—è·ç¦»ä¸Šæ¬¡å¿ƒè·³çš„æ—¶é—´
        time_since_last = (datetime.now() - self.last_heartbeat).total_seconds()
        
        # å¦‚æœè¶…è¿‡å¿ƒè·³é—´éš”ï¼Œéœ€è¦å‘é€å¿ƒè·³
        return time_since_last >= self.heartbeat_interval
    
    def send_heartbeat(self):
        """å‘é€å¿ƒè·³ï¼Œè¿”å›æ˜¯å¦æˆåŠŸ"""
        with self.lock:
            if not self.mail or self.connection_state != ConnectionState.CONNECTED:
                return False
            
            try:
                # å‘é€NOOPå‘½ä»¤æ£€æŸ¥è¿æ¥çŠ¶æ€
                status, _ = self.mail.noop()
                if status == 'OK':
                    self.last_heartbeat = datetime.now()
                    self.consecutive_failures = 0
                    return True
                else:
                    self.connection_state = ConnectionState.ERROR
                    self.consecutive_failures += 1
                    logger.debug(f"å¿ƒè·³å“åº”å¼‚å¸¸: {status}")
                    return False
            except Exception as e:
                self.connection_state = ConnectionState.ERROR
                self.consecutive_failures += 1
                logger.debug(f"å¿ƒè·³å‘é€å¤±è´¥: {e}")
                return False
    
    def check_connection(self):
        """æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼ˆå¦‚æœéœ€è¦ä¼šå‘é€å¿ƒè·³ï¼‰"""
        with self.lock:
            if not self.mail or self.connection_state != ConnectionState.CONNECTED:
                return False
            
            # å¦‚æœéœ€è¦ï¼Œå‘é€å¿ƒè·³
            if self.should_send_heartbeat():
                return self.send_heartbeat()
            
            # ä¸éœ€è¦å‘é€å¿ƒè·³ï¼Œè¿æ¥çŠ¶æ€æ­£å¸¸
            return True

class MainFrame(ttk.Frame):
    """ä¸»ç›‘æ§ç•Œé¢"""
    def __init__(self, parent, controller, server, port, username, password,
                 keywords, ignore_keywords, keyword_file, ignore_keyword_file,
                 sound_file):
        super().__init__(parent)
        self.controller = controller
        self.server = server
        self.port = port
        self.username = username
        self.password = password
        self.keywords = keywords
        self.ignore_keywords = ignore_keywords
        self.keyword_file = keyword_file
        self.ignore_keyword_file = ignore_keyword_file
        self.keyword_watcher = None
        self.ignore_watcher = None
        self.sound_file = sound_file
        self.alert_thread = None
        self.alert_stop_flag = threading.Event()
        self.alert_lock = threading.Lock()
        self.email_details = {}
        self.email_tree_items = {}
        self.is_monitoring = False
        self.should_stop = False
        self.monitor_thread = None
        self.alerting_emails = set()
        self.processed_emails = set()
        self.thread_lock = threading.Lock()
        self.scan_interval = 300
        self.time_check_enabled = True
        self.time_threshold = 30
        self.data_lock = threading.Lock()
        self.force_check_event = threading.Event()
        
        # æ–°å¢è¿æ¥ç®¡ç†å™¨
        self.connection_manager = ConnectionManager(
            server, port, username, password, self.scan_interval
        )
        self.last_scan_time = None
        self.retry_count = 0
        self.max_retries = 5
        self.retry_delay_base = 5  # æŒ‡æ•°é€€é¿åŸºç¡€å»¶è¿Ÿ
        
        self.create_widgets()
        self.log_message("ğŸ”§ ç›‘æ§ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
        self.log_message(f"ğŸ“§ ç›‘æ§é‚®ç®±: {username}")
        self.log_message(f"â° æ‰«æé¢‘ç‡: æ¯{self.scan_interval//60}åˆ†é’Ÿ")
        self.log_message(f"ğŸ”‘ ç›‘æ§å…³é”®å­—: {len(keywords)}ä¸ª")
        if ignore_keywords:
            self.log_message(f"ğŸ”• å¿½ç•¥å…³é”®å­—é…å¯¹: {len(ignore_keywords)}ä¸ª")
        if self.time_check_enabled:
            self.log_message(f"â±ï¸ æ—¶é—´æ£€æŸ¥: å¯ç”¨ (é˜ˆå€¼: {self.time_threshold}åˆ†é’Ÿ)")
        if sound_file:
            self.log_message(f"ğŸ”Š è‡ªå®šä¹‰å£°éŸ³: {os.path.basename(sound_file)}")
        self.start_file_watchers()

    def start_file_watchers(self):
        """å¯åŠ¨æ–‡ä»¶ç›‘è§†å™¨"""
        if self.keyword_file and os.path.exists(self.keyword_file):
            self.keyword_watcher = FileWatcher(
                self.keyword_file,
                self.on_keyword_file_changed,
                check_interval=2
            )
            self.keyword_watcher.start()
            self.log_message(f"ğŸ‘ï¸ å¼€å§‹ç›‘è§†å…³é”®å­—æ–‡ä»¶: {os.path.basename(self.keyword_file)}")
        if self.ignore_keyword_file and os.path.exists(self.ignore_keyword_file):
            self.ignore_watcher = FileWatcher(
                self.ignore_keyword_file,
                self.on_ignore_file_changed,
                check_interval=2
            )
            self.ignore_watcher.start()
            self.log_message(f"ğŸ‘ï¸ å¼€å§‹ç›‘è§†å¿½ç•¥å…³é”®å­—æ–‡ä»¶: {os.path.basename(self.ignore_keyword_file)}")

    def stop_file_watchers(self):
        """åœæ­¢æ–‡ä»¶ç›‘è§†å™¨"""
        if self.keyword_watcher:
            self.keyword_watcher.stop()
        if self.ignore_watcher:
            self.ignore_watcher.stop()

    def on_keyword_file_changed(self):
        """å…³é”®å­—æ–‡ä»¶å˜åŒ–å›è°ƒ"""
        self.after(0, self._handle_keyword_file_change)

    def on_ignore_file_changed(self):
        """å¿½ç•¥å…³é”®å­—æ–‡ä»¶å˜åŒ–å›è°ƒ"""
        self.after(0, self._handle_ignore_file_change)

    def _handle_keyword_file_change(self):
        """å¤„ç†å…³é”®å­—æ–‡ä»¶å˜åŒ–"""
        try:
            new_keywords = set()
            with open(self.keyword_file, "r", encoding="utf-8") as f:
                for line in f:
                    keyword = line.strip()
                    if keyword:
                        new_keywords.add(keyword)
            if new_keywords != self.keywords:
                old_count = len(self.keywords)
                self.keywords = new_keywords
                new_count = len(self.keywords)
                self.log_message(f"ğŸ”„ å…³é”®å­—æ–‡ä»¶å·²æ›´æ–°: {old_count} â†’ {new_count} ä¸ªå…³é”®å­—")
        except Exception as e:
            self.log_message(f"âŒ é‡æ–°åŠ è½½å…³é”®å­—æ–‡ä»¶å¤±è´¥: {e}")

    def _handle_ignore_file_change(self):
        """å¤„ç†å¿½ç•¥å…³é”®å­—æ–‡ä»¶å˜åŒ–"""
        try:
            new_ignore_keywords = []
            with open(self.ignore_keyword_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or ':' not in line:
                        continue
                    parts = line.split(':', 1)
                    subject_keyword = parts[0].strip()
                    body_keywords = [kw.strip() for kw in parts[1].strip().split(',') if kw.strip()]
                    if subject_keyword and body_keywords:
                        new_ignore_keywords.append({
                            'subject': subject_keyword,
                            'body_keywords': body_keywords
                        })
            if new_ignore_keywords != self.ignore_keywords:
                old_count = len(self.ignore_keywords)
                self.ignore_keywords = new_ignore_keywords
                new_count = len(new_ignore_keywords)
                self.log_message(f"ğŸ”„ å¿½ç•¥å…³é”®å­—æ–‡ä»¶å·²æ›´æ–°: {old_count} â†’ {new_count} ä¸ªé…å¯¹")
        except Exception as e:
            self.log_message(f"âŒ é‡æ–°åŠ è½½å¿½ç•¥å…³é”®å­—æ–‡ä»¶å¤±è´¥: {e}")

    def create_widgets(self):
        """åˆ›å»ºç•Œé¢ç»„ä»¶"""
        main_frame = ttk.Frame(self, padding=15)
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # æ ‡é¢˜æ 
        title_frame = ttk.Frame(main_frame)
        title_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # å·¦ä¾§ï¼šæ ‡é¢˜å’ŒçŠ¶æ€
        left_frame = ttk.Frame(title_frame)
        left_frame.pack(side=tk.LEFT, fill=tk.Y)
        ttk.Label(left_frame, text="ğŸ“§ é‚®ç®±ç›‘æ§é¢æ¿", font=('Arial', 16, 'bold'), foreground="#2C3E50").pack(anchor=tk.W)
        
        # çŠ¶æ€æ˜¾ç¤º
        self.status_var = tk.StringVar(value="ğŸŸ¢ å°±ç»ª")
        self.connection_status_var = tk.StringVar(value="ğŸ“¡ è¿æ¥çŠ¶æ€: æœªè¿æ¥")
        ttk.Label(left_frame, textvariable=self.status_var, font=('Arial', 11), foreground="#27AE60").pack(anchor=tk.W, pady=(5, 0))
        ttk.Label(left_frame, textvariable=self.connection_status_var, font=('Arial', 10), foreground="#666").pack(anchor=tk.W)
        
        # å³ä¾§ï¼šæ§åˆ¶é¢æ¿
        right_frame = ttk.Frame(title_frame)
        right_frame.pack(side=tk.RIGHT, fill=tk.Y)
        
        # æ‰«æé—´éš”è®¾ç½®
        interval_frame = ttk.Frame(right_frame)
        interval_frame.pack(anchor=tk.E, pady=2)
        ttk.Label(interval_frame, text="æ‰«æé—´éš”(åˆ†é’Ÿ):").pack(side=tk.LEFT)
        self.interval_var = tk.StringVar(value=str(self.scan_interval // 60))
        ttk.Entry(interval_frame, textvariable=self.interval_var, width=6).pack(side=tk.LEFT, padx=5)
        ttk.Button(interval_frame, text="æ›´æ–°", command=self.update_interval, width=8).pack(side=tk.LEFT)
        
        # æ—¶é—´æ£€æŸ¥è®¾ç½®
        time_frame = ttk.Frame(right_frame)
        time_frame.pack(anchor=tk.E, pady=2)
        self.time_check_var = tk.BooleanVar(value=self.time_check_enabled)
        ttk.Checkbutton(time_frame, text="æ—¶é—´æ£€æŸ¥", variable=self.time_check_var,
                        command=self.update_time_check).pack(side=tk.LEFT)
        ttk.Label(time_frame, text="é˜ˆå€¼(åˆ†é’Ÿ):").pack(side=tk.LEFT, padx=(10, 5))
        self.time_threshold_var = tk.StringVar(value=str(self.time_threshold))
        ttk.Entry(time_frame, textvariable=self.time_threshold_var, width=6).pack(side=tk.LEFT)
        ttk.Button(time_frame, text="æ›´æ–°", command=self.update_time_threshold, width=8).pack(side=tk.LEFT, padx=5)
        
        # åˆ†å‰²çª—å£
        self.paned_window = PanedWindow(main_frame, orient=tk.VERTICAL, sashrelief=tk.RAISED, sashwidth=5)
        self.paned_window.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        main_frame.rowconfigure(1, weight=1)
        main_frame.columnconfigure(0, weight=1)
        
        # é‚®ä»¶åˆ—è¡¨
        email_frame = ttk.LabelFrame(self.paned_window, text="ğŸ“¬ åŒ¹é…åˆ°çš„é‚®ä»¶ (åŒå‡»æŸ¥çœ‹è¯¦æƒ…)", padding=10)
        email_frame.columnconfigure(0, weight=1)
        email_frame.rowconfigure(0, weight=1)
        columns = ("æ”¶åˆ°æ—¶é—´", "é‚®ä»¶ä¸»é¢˜", "åŒ¹é…å…³é”®å­—", "å¤„ç†çŠ¶æ€")
        self.email_tree = ttk.Treeview(email_frame, columns=columns, show="headings", height=8)
        col_configs = [("æ”¶åˆ°æ—¶é—´", 180), ("é‚®ä»¶ä¸»é¢˜", 500), ("åŒ¹é…å…³é”®å­—", 150), ("å¤„ç†çŠ¶æ€", 120)]
        for col, width in col_configs:
            self.email_tree.heading(col, text=col)
            self.email_tree.column(col, width=width)
        self.email_tree.bind('<Double-1>', self.show_email_detail)
        scrollbar = ttk.Scrollbar(email_frame, orient=tk.VERTICAL, command=self.email_tree.yview)
        self.email_tree.configure(yscrollcommand=scrollbar.set)
        self.email_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # æ—¥å¿—åŒºåŸŸ
        log_frame = ttk.LabelFrame(self.paned_window, text="ğŸ“ ç›‘æ§æ—¥å¿—", padding=10)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        self.log_text = tk.Text(log_frame, wrap=tk.WORD, font=('Arial', 10))
        log_scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        self.log_text.configure(yscrollcommand=log_scrollbar.set)
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        log_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        self.paned_window.add(email_frame)
        self.paned_window.add(log_frame)
        self.paned_window.paneconfig(email_frame, height=400, minsize=150)
        self.paned_window.paneconfig(log_frame, height=200, minsize=100)
        
        # æ§åˆ¶æŒ‰é’®
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=2, column=0, pady=10)
        buttons = [
            ("â–¶ï¸ å¼€å§‹ç›‘æ§", self.start_monitoring, None, "start_button"),
            ("â¹ï¸ åœæ­¢ç›‘æ§", self.stop_monitoring, tk.DISABLED, "stop_button"),
            ("ğŸ“¥ ç«‹å³æ”¶å–", self.check_now, tk.DISABLED, "check_now_button"),
            ("ğŸ”Œ æ‰‹åŠ¨é‡è¿", self.manual_reconnect, tk.DISABLED, "reconnect_button"),
            ("ğŸ”‡ åœæ­¢å£°éŸ³", self.stop_sound, tk.DISABLED, "sound_button"),
            ("ğŸ—‘ï¸ æ¸…ç©ºåˆ—è¡¨", self.clear_list, None, None),
            ("ğŸ”„ ç«‹å³æ£€æŸ¥æ–‡ä»¶", self.reload_keywords_manual, None, None),
            ("â†©ï¸ è¿”å›ç™»å½•", self.return_to_login, None, None)
        ]
        for i, (text, command, state, var_name) in enumerate(buttons):
            btn = ttk.Button(control_frame, text=text, command=command, width=15, state=state)
            btn.grid(row=0, column=i, padx=5)
            if var_name:
                setattr(self, var_name, btn)

    def return_to_login(self):
        """è¿”å›åˆ°ç™»å½•ç•Œé¢"""
        try:
            self.log_message("â†©ï¸ æ­£åœ¨è¿”å›ç™»å½•ç•Œé¢...")
            self.stop_monitoring()
            self.stop_file_watchers()
            # æ·»åŠ å¼‚å¸¸å¤„ç†ï¼Œé¿å…disconnectå¤±è´¥é˜»æ­¢ç•Œé¢åˆ‡æ¢
            try:
                self.connection_manager.disconnect()
            except Exception as e:
                self.log_message(f"âš ï¸ æ–­å¼€è¿æ¥æ—¶å‡ºé”™: {e}")
                logger.error(f"æ–­å¼€è¿æ¥é”™è¯¯: {traceback.format_exc()}")
            
            # åœ¨ä¸»çº¿ç¨‹ä¸­åˆ‡æ¢ç•Œé¢
            self.after(0, lambda: self.controller.show_login_frame())
        except Exception as e:
            self.log_message(f"âŒ è¿”å›ç™»å½•å¤±è´¥: {e}")
            logger.error(f"è¿”å›ç™»å½•å¤±è´¥: {traceback.format_exc()}")
            # å³ä½¿å‡ºé”™ä¹Ÿå°è¯•åˆ‡æ¢ç•Œé¢
            try:
                self.after(0, lambda: self.controller.show_login_frame())
            except:
                pass

    def update_connection_status(self):
        """æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º"""
        status = self.connection_manager.connection_state
        status_map = {
            ConnectionState.DISCONNECTED: "ğŸ”´ æœªè¿æ¥",
            ConnectionState.CONNECTING: "ğŸŸ¡ è¿æ¥ä¸­...",
            ConnectionState.CONNECTED: "ğŸŸ¢ å·²è¿æ¥",
            ConnectionState.RECONNECTING: "ğŸŸ  é‡è¿ä¸­...",
            ConnectionState.ERROR: "ğŸ”´ è¿æ¥é”™è¯¯"
        }
        display_text = status_map.get(status, "â“ æœªçŸ¥çŠ¶æ€")
        self.connection_status_var.set(f"ğŸ“¡ è¿æ¥çŠ¶æ€: {display_text}")

    def check_now(self):
        """ç«‹å³æ”¶å–é‚®ä»¶"""
        if not self.is_monitoring:
            self.log_message("âš ï¸ è¯·å…ˆå¯åŠ¨ç›‘æ§åå†ç‚¹å‡»ç«‹å³æ”¶å–")
            return
        self.log_message("ğŸš€ æ‰‹åŠ¨è§¦å‘ç«‹å³æ”¶å–...")
        self.force_check_event.set()

    def manual_reconnect(self):
        """æ‰‹åŠ¨é‡è¿"""
        if not self.is_monitoring:
            self.log_message("âš ï¸ è¯·å…ˆå¯åŠ¨ç›‘æ§")
            return
        self.log_message("ğŸ”„ æ‰‹åŠ¨è§¦å‘é‡æ–°è¿æ¥...")
        self.retry_count = 0
        self.force_check_event.set()

    def update_interval(self):
        """æ›´æ–°æ‰«æé—´éš”"""
        try:
            minutes = int(self.interval_var.get())
            if 1 <= minutes <= 1440:
                new_scan_interval = minutes * 60
                
                # æ›´æ–°æ‰«æé—´éš”
                old_interval = self.scan_interval
                self.scan_interval = new_scan_interval
                
                # æ›´æ–°è¿æ¥ç®¡ç†å™¨çš„å¿ƒè·³é—´éš”
                self.connection_manager.update_scan_interval(new_scan_interval)
                
                self.log_message(f"â° æ‰«æé—´éš”æ›´æ–°ä¸º {minutes} åˆ†é’Ÿ")
                return True
            else:
                messagebox.showerror("é”™è¯¯", "æ‰«æé—´éš”å¿…é¡»åœ¨1-1440åˆ†é’ŸèŒƒå›´å†…")
                return False
        except ValueError:
            messagebox.showerror("é”™è¯¯", "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
            return False

    def update_time_check(self):
        """æ›´æ–°æ—¶é—´æ£€æŸ¥å¼€å…³"""
        self.time_check_enabled = self.time_check_var.get()
        status = "å¯ç”¨" if self.time_check_enabled else "ç¦ç”¨"
        self.log_message(f"â±ï¸ æ—¶é—´æ£€æŸ¥å·²{status}")

    def update_time_threshold(self):
        """æ›´æ–°æ—¶é—´é˜ˆå€¼"""
        try:
            threshold = int(self.time_threshold_var.get())
            if 1 <= threshold <= 1440:
                self.time_threshold = threshold
                self.log_message(f"â±ï¸ æ—¶é—´é˜ˆå€¼æ›´æ–°ä¸º {threshold} åˆ†é’Ÿ")
                return True
            else:
                messagebox.showerror("é”™è¯¯", "æ—¶é—´é˜ˆå€¼å¿…é¡»åœ¨1-1440åˆ†é’ŸèŒƒå›´å†…")
                return False
        except ValueError:
            messagebox.showerror("é”™è¯¯", "è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—")
            return False

    def log_message(self, message):
        """è®°å½•æ—¥å¿—"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        self.after(0, self._update_log, log_entry)
        logger.info(message)

    def _update_log(self, log_entry):
        """å®‰å…¨æ›´æ–°æ—¥å¿—"""
        try:
            self.log_text.insert(tk.END, log_entry)
            self.log_text.see(tk.END)
        except Exception as e:
            logger.error(f"æ›´æ–°æ—¥å¿—é”™è¯¯: {e}")

    def add_email(self, email_id, time_str, subject, keywords, status, email_data):
        """æ·»åŠ é‚®ä»¶åˆ°åˆ—è¡¨"""
        subject_clean = self.clean_subject(subject)
        subject_display = subject_clean[:100] + "..." if len(subject_clean) > 100 else subject_clean
        email_data['subject'] = subject_clean
        if 'raw_msg' in email_data:
            del email_data['raw_msg']
        with self.data_lock:
            self.email_details[email_id] = email_data
        self.after(0, self._update_email_tree, email_id, time_str, subject_display, keywords, status)

    def clean_subject(self, text):
        """æ¸…ç†æ–‡æœ¬ä¸­çš„æ¢è¡Œç¬¦å’Œå¤šä½™ç©ºæ ¼"""
        if not text:
            return "æ— ä¸»é¢˜"
        text = re.sub(r'[\r\n]+', ' ', text)
        text = re.sub(r'\s+', ' ', text)
        return text.strip()

    def _update_email_tree(self, email_id, time_str, subject, keywords, status):
        """æ›´æ–°é‚®ä»¶åˆ—è¡¨"""
        item_id = self.email_tree.insert("", 0, values=(time_str, subject, keywords, status))
        self.email_tree_items[email_id] = item_id
        status_colors = {
            "æ­£å¸¸è­¦æŠ¥": "red",
            "å·²å¿½ç•¥": "blue",
            "æ—¶é—´è¿‡æœŸ": "orange",
            "å·²å¤„ç†": "green"
        }
        if status in status_colors:
            self.email_tree.item(item_id, tags=(status,))
            self.email_tree.tag_configure(status, foreground=status_colors[status])

    def update_email_status(self, email_id, new_status):
        """æ›´æ–°é‚®ä»¶çŠ¶æ€"""
        with self.data_lock:
            if email_id in self.email_tree_items:
                item_id = self.email_tree_items[email_id]
                current_values = self.email_tree.item(item_id, 'values')
                new_values = (current_values[0], current_values[1], current_values[2], new_status)
                self.email_tree.item(item_id, values=new_values)
                if email_id in self.email_details:
                    self.email_details[email_id]['status'] = new_status
                status_colors = {"æ­£å¸¸è­¦æŠ¥": "red", "å·²å¿½ç•¥": "blue", "æ—¶é—´è¿‡æœŸ": "orange", "å·²å¤„ç†": "green"}
                if new_status in status_colors:
                    self.email_tree.item(item_id, tags=(new_status,))
                    self.email_tree.tag_configure(new_status, foreground=status_colors[new_status])

    def show_email_detail(self, event):
        """æ˜¾ç¤ºé‚®ä»¶è¯¦æƒ…"""
        selection = self.email_tree.selection()
        if not selection:
            return
        item_id = selection[0]
        email_id = None
        with self.data_lock:
            for eid, tid in self.email_tree_items.items():
                if tid == item_id:
                    email_id = eid
                    break
            if email_id and email_id in self.email_details:
                EmailDetailDialog(self, self.email_details[email_id])
            else:
                messagebox.showwarning("æç¤º", "æ— æ³•æ‰¾åˆ°é‚®ä»¶è¯¦ç»†ä¿¡æ¯")

    def clear_list(self):
        """æ¸…ç©ºåˆ—è¡¨ï¼ˆä½†ä¿ç•™å·²å¤„ç†é‚®ä»¶è®°å½•ï¼‰"""
        for item in self.email_tree.get_children():
            self.email_tree.delete(item)
        with self.data_lock:
            self.email_details.clear()
            self.email_tree_items.clear()
            # é‡è¦ï¼šä¸è¦æ¸…é™¤ processed_emailsï¼Œåªæ¸…é™¤ alerting_emails
            # self.processed_emails.clear()  # æ³¨é‡Šæ‰è¿™è¡Œï¼
        with self.thread_lock:
            self.alerting_emails.clear()
        self.stop_sound()
        self.log_message("ğŸ“­ å·²æ¸…ç©ºé‚®ä»¶åˆ—è¡¨ï¼ˆä¿ç•™å·²å¤„ç†è®°å½•ï¼‰")

    def reload_keywords_manual(self):
        """æ‰‹åŠ¨é‡æ–°åŠ è½½å…³é”®å­—"""
        self._handle_keyword_file_change()
        self._handle_ignore_file_change()
        self.log_message("âœ… å…³é”®å­—å·²é‡æ–°åŠ è½½")

    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        if self.is_monitoring:
            self.log_message("âš ï¸ ç›‘æ§å·²ç»åœ¨è¿è¡Œä¸­")
            return
        self.is_monitoring = True
        self.should_stop = False
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.check_now_button.config(state=tk.NORMAL)
        self.reconnect_button.config(state=tk.NORMAL)
        self.sound_button.config(state=tk.NORMAL)
        self.status_var.set("ğŸŸ¡ ç›‘æ§ä¸­...")
        self.log_message("ğŸš€ å¼€å§‹é‚®ç®±ç›‘æ§")
        self.log_message(f"â° æ‰«æé¢‘ç‡: æ¯{self.scan_interval//60}åˆ†é’Ÿ")
        if self.ignore_keywords:
            self.log_message(f"ğŸ”• å·²å¯ç”¨ {len(self.ignore_keywords)} ä¸ªå¿½ç•¥é…å¯¹")
        if self.time_check_enabled:
            self.log_message(f"â±ï¸ æ—¶é—´æ£€æŸ¥å·²å¯ç”¨ï¼Œé˜ˆå€¼: {self.time_threshold}åˆ†é’Ÿ")
        if self.sound_file:
            self.log_message(f"ğŸ”Š ä½¿ç”¨è‡ªå®šä¹‰å‘Šè­¦å£°éŸ³")
        self.log_message("ğŸ“Š å¯åŠ¨ç›‘æ§çº¿ç¨‹...")
        self.monitor_thread = threading.Thread(target=self.monitor_loop, daemon=True)
        self.monitor_thread.start()

    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.is_monitoring = False
        self.should_stop = True
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.check_now_button.config(state=tk.DISABLED)
        self.reconnect_button.config(state=tk.DISABLED)
        self.sound_button.config(state=tk.DISABLED)
        self.status_var.set("ğŸ”´ å·²åœæ­¢")
        self.log_message("â¹ï¸ åœæ­¢ç›‘æ§")
        self.stop_sound()
        # æ–­å¼€è¿æ¥
        try:
            self.connection_manager.disconnect()
        except Exception as e:
            self.log_message(f"âš ï¸ æ–­å¼€è¿æ¥æ—¶å‡ºé”™: {e}")

    def stop_sound(self):
        """åœæ­¢å£°éŸ³"""
        if not AUDIO_AVAILABLE:
            return
        self.alert_stop_flag.set()
        try:
            winsound.PlaySound(None, winsound.SND_PURGE)
            self.log_message("ğŸ”‡ åœæ­¢å£°éŸ³")
        except Exception as e:
            self.log_message(f"åœæ­¢å£°éŸ³å¤±è´¥: {e}")

    def play_alert_sound_loop(self):
        """å¾ªç¯æ’­æ”¾å‘Šè­¦å£°éŸ³"""
        if not AUDIO_AVAILABLE:
            return
        self.alert_stop_flag.clear()
        self.log_message("ğŸ”Š å¼€å§‹å¾ªç¯æ’­æ”¾å‘Šè­¦å£°éŸ³")
        try:
            while not self.alert_stop_flag.is_set() and not self.should_stop:
                with self.alert_lock:
                    if not self.alerting_emails:
                        break
                if self.sound_file and os.path.exists(self.sound_file):
                    winsound.PlaySound(self.sound_file, winsound.SND_FILENAME | winsound.SND_ASYNC)
                else:
                    winsound.MessageBeep()
                for _ in range(15):
                    if self.alert_stop_flag.is_set() or self.should_stop:
                        break
                    time.sleep(0.1)
        except Exception as e:
            self.log_message(f"æ’­æ”¾å‘Šè­¦å£°éŸ³å¤±è´¥: {e}")
        finally:
            winsound.PlaySound(None, winsound.SND_PURGE)
            self.log_message("ğŸ”‡ å‘Šè­¦å£°éŸ³åœæ­¢")

    def trigger_alert(self):
        """è§¦å‘è­¦æŠ¥"""
        with self.alert_lock:
            if not self.alerting_emails:
                return
            self.alert_stop_flag.set()
            if self.alert_thread and self.alert_thread.is_alive():
                try:
                    self.alert_thread.join(timeout=2.0)
                except:
                    pass
            self.alert_stop_flag.clear()
            self.alert_thread = threading.Thread(target=self.play_alert_sound_loop, daemon=True)
            self.alert_thread.start()

    def check_keywords(self, subject, body):
        """æ£€æŸ¥å…³é”®è¯"""
        content = f"{subject} {body}".lower()
        return [keyword for keyword in self.keywords if keyword.lower() in content]

    def check_ignore_keywords(self, subject, body):
        """æ£€æŸ¥å¿½ç•¥å…³é”®è¯"""
        if not self.ignore_keywords:
            return (False, None)
        subject_lower = subject.lower()
        body_lower = body.lower()
        for pair in self.ignore_keywords:
            if pair['subject'].lower() in subject_lower:
                if all(body_keyword.lower() in body_lower for body_keyword in pair['body_keywords']):
                    return (True, pair)
        return (False, None)

    def get_email_body(self, msg):
        """è·å–é‚®ä»¶æ­£æ–‡"""
        body = ""
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    content_type = part.get_content_type()
                    if "attachment" in str(part.get("Content-Disposition", "")):
                        continue
                    if content_type in ["text/plain", "text/html"]:
                        try:
                            payload = part.get_payload(decode=True)
                            if payload:
                                charset = part.get_content_charset() or 'utf-8'
                                content = payload.decode(charset, errors='ignore')
                                body += content
                        except:
                            pass
            else:
                content_type = msg.get_content_type()
                if content_type in ["text/plain", "text/html"]:
                    try:
                        payload = msg.get_payload(decode=True)
                        if payload:
                            charset = msg.get_content_charset() or 'utf-8'
                            body = payload.decode(charset, errors='ignore')
                    except:
                        pass
            return body[:10000]
        except Exception as e:
            self.log_message(f"æå–æ­£æ–‡å¤±è´¥: {e}")
            return ""

    def decode_header(self, text):
        """è§£ç é‚®ä»¶å¤´å¹¶æ¸…ç†æ¢è¡Œç¬¦"""
        if not text:
            return ""
        try:
            decoded_parts = decode_header(text)
            result = ""
            for part, encoding in decoded_parts:
                if isinstance(part, bytes):
                    try:
                        decoded = part.decode(encoding or 'utf-8', errors='ignore')
                        result += self.clean_subject(decoded)
                    except:
                        result += part.decode('utf-8', errors='ignore')
                else:
                    result += self.clean_subject(str(part))
            return result
        except:
            return self.clean_subject(str(text))

    def mark_email_as_read(self, email_id):
        """æ ‡è®°é‚®ä»¶ä¸ºå·²è¯»"""
        try:
            self.connection_manager.mail.store(email_id, '+FLAGS', '\\Seen')
        except Exception as e:
            self.log_message(f"æ ‡è®°é‚®ä»¶ä¸ºå·²è¯»å¤±è´¥: {e}")

    def perform_scan(self):
        """æ‰§è¡Œä¸€æ¬¡æ‰«æ"""
        try:
            # æ£€æŸ¥è¿æ¥çŠ¶æ€
            if not self.connection_manager.check_connection():
                self.log_message("ğŸ”Œ è¿æ¥æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•é‡æ–°è¿æ¥...")
                self.update_connection_status()
                try:
                    if self.connection_manager.reconnect():
                        self.log_message("âœ… é‡æ–°è¿æ¥æˆåŠŸ")
                        self.update_connection_status()
                    else:
                        self.log_message("âŒ é‡è¿å¤±è´¥ï¼Œç¨åé‡è¯•")
                        return False
                except Exception as e:
                    self.log_message(f"âŒ é‡è¿å¤±è´¥: {e}")
                    return False
            
            # æœç´¢æœªè¯»é‚®ä»¶
            _, messages = self.connection_manager.mail.search(None, 'UNSEEN')
            if messages[0]:
                email_ids = messages[0].split()
                self.log_message(f"ğŸ“§ å‘ç° {len(email_ids)} å°æ–°é‚®ä»¶")
                batch_size = 50
                for i in range(0, len(email_ids), batch_size):
                    batch = email_ids[i:i + batch_size]
                    self.log_message(f"ğŸ” å¤„ç†æ‰¹æ¬¡ {i//batch_size + 1}/{(len(email_ids)-1)//batch_size + 1} ({len(batch)} å°é‚®ä»¶)")
                    for email_id in batch:
                        if self.should_stop:
                            break
                        try:
                            # è·å–é‚®ä»¶UID
                            _, uid_data = self.connection_manager.mail.fetch(email_id, '(UID)')
                            uid_match = re.search(r'UID (\d+)', uid_data[0].decode())
                            if uid_match:
                                email_uid = uid_match.group(1)
                                email_key = f"{self.username}:{email_uid}"
                            else:
                                email_key = f"{self.username}:{email_id.decode()}"
                        except:
                            email_key = f"{self.username}:{email_id.decode()}"
                        
                        with self.data_lock:
                            if email_key in self.processed_emails:
                                continue
                        
                        try:
                            # è·å–é‚®ä»¶å†…å®¹
                            _, msg_data = self.connection_manager.mail.fetch(email_id, '(RFC822)')
                            msg = email.message_from_bytes(msg_data[0][1])
                            subject = self.decode_header(msg.get("subject", ""))
                            from_addr = self.decode_header(msg.get("from", ""))
                            to_addr = self.decode_header(msg.get("to", ""))
                            date_str = self.decode_header(msg.get("date", ""))
                            body = self.get_email_body(msg)
                            email_date = TimeChecker.parse_email_date(date_str)
                            email_data = {
                                'id': email_key,
                                'from': from_addr,
                                'to': to_addr,
                                'date': date_str,
                                'subject': subject,
                                'body': body
                            }
                            self.log_message(f"ğŸ“¨ å¤„ç†é‚®ä»¶: {subject[:50]}...")
                            
                            # æ£€æŸ¥å¿½ç•¥å…³é”®è¯
                            is_ignored, ignore_pair = self.check_ignore_keywords(subject, body)
                            if is_ignored:
                                body_keywords_str = ", ".join(ignore_pair['body_keywords'])
                                self.log_message(f"ğŸ”• å¿½ç•¥é…å¯¹: {ignore_pair['subject']}:{body_keywords_str}")
                                self.add_email(
                                    email_key,
                                    datetime.now().strftime("%H:%M:%S"),
                                    subject,
                                    f"å¿½ç•¥é…å¯¹: {ignore_pair['subject']}",
                                    "å·²å¿½ç•¥",
                                    email_data
                                )
                                with self.data_lock:
                                    self.processed_emails.add(email_key)
                                self.mark_email_as_read(email_id)
                                continue
                            
                            # æ£€æŸ¥æ—¶é—´è¿‡æœŸ
                            if self.time_check_enabled:
                                is_old, reason, ref_time = TimeChecker.is_old_email(email_date, body, self.time_threshold)
                                if is_old:
                                    time_str = ref_time.strftime("%Y-%m-%d %H:%M:%S") if ref_time else "æœªçŸ¥æ—¶é—´"
                                    self.log_message(f"â±ï¸ {reason}")
                                    self.add_email(
                                        email_key,
                                        datetime.now().strftime("%H:%M:%S"),
                                        subject,
                                        reason,
                                        "æ—¶é—´è¿‡æœŸ",
                                        email_data
                                    )
                                    with self.data_lock:
                                        self.processed_emails.add(email_key)
                                    self.mark_email_as_read(email_id)
                                    continue
                            
                            # æ£€æŸ¥ç›‘æ§å…³é”®è¯
                            matched_keywords = self.check_keywords(subject, body)
                            if matched_keywords:
                                keywords_str = ", ".join(matched_keywords)
                                self.log_message(f"ğŸ”¥ å‘½ä¸­å…³é”®è¯: {keywords_str}")
                                self.add_email(
                                    email_key,
                                    datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                                    subject,
                                    keywords_str,
                                    "æ­£å¸¸è­¦æŠ¥",
                                    email_data
                                )
                                with self.thread_lock:
                                    self.alerting_emails.add(email_key)
                                self.trigger_alert()
                                with self.data_lock:
                                    self.processed_emails.add(email_key)
                                self.mark_email_as_read(email_id)
                                
                        except Exception as e:
                            self.log_message(f"âŒ å¤„ç†é‚®ä»¶å¤±è´¥: {e}")
                            logger.error(f"å¤„ç†é‚®ä»¶å¤±è´¥è¯¦ç»†ä¿¡æ¯: {traceback.format_exc()}")
                            continue
                    time.sleep(0.5)
            else:
                self.log_message("ğŸ“­ æš‚æ— æ–°é‚®ä»¶")
            
            # è®°å½•æ‰«ææ—¶é—´
            self.last_scan_time = datetime.now()
            self.retry_count = 0  # é‡ç½®é‡è¯•è®¡æ•°
            return True
            
        except Exception as e:
            error_msg = str(e)
            self.log_message(f"âŒ æ‰«æå¤±è´¥: {error_msg}")
            logger.error(f"æ‰«æå¤±è´¥è¯¦ç»†ä¿¡æ¯: {traceback.format_exc()}")
            return False

    def monitor_loop(self):
        """ç›‘æ§ä¸»å¾ªç¯"""
        self.log_message("ğŸ”„ åˆå§‹åŒ–è¿æ¥...")
        try:
            self.connection_manager.connect()
            self.update_connection_status()
            self.log_message("âœ… è¿æ¥æˆåŠŸ")
        except Exception as e:
            self.log_message(f"âŒ åˆå§‹è¿æ¥å¤±è´¥: {e}")
            self.update_connection_status()
            self.after(0, self.stop_monitoring)
            return
        
        last_heartbeat_time = datetime.now()
        
        while self.is_monitoring and not self.should_stop:
            try:
                # æ£€æŸ¥æ˜¯å¦éœ€è¦å‘é€å¿ƒè·³
                now = datetime.now()
                if (now - last_heartbeat_time).total_seconds() >= 30:  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡å¿ƒè·³
                    if self.connection_manager.send_heartbeat():
                        last_heartbeat_time = now
                        # æ›´æ–°è¿æ¥çŠ¶æ€æ˜¾ç¤º
                        self.update_connection_status()
                
                # æ£€æŸ¥å¼ºåˆ¶æ£€æŸ¥äº‹ä»¶
                if self.force_check_event.is_set():
                    self.log_message("ğŸš€ æ‰§è¡Œå¼ºåˆ¶æ£€æŸ¥...")
                    self.force_check_event.clear()
                    self.perform_scan()
                    if self.last_scan_time:
                        next_scan_seconds = self.scan_interval - (datetime.now() - self.last_scan_time).total_seconds()
                        if next_scan_seconds > 0:
                            self.log_message(f"â³ ç­‰å¾… {int(next_scan_seconds//60)}åˆ†{int(next_scan_seconds%60)}ç§’åä¸‹æ¬¡æ£€æŸ¥...")
                
                # è®¡ç®—è·ç¦»ä¸‹æ¬¡æ‰«æçš„æ—¶é—´
                if self.last_scan_time:
                    time_since_last_scan = (now - self.last_scan_time).total_seconds()
                    time_until_next_scan = max(0, self.scan_interval - time_since_last_scan)
                else:
                    time_until_next_scan = 0
                
                # å¦‚æœåˆ°äº†æ‰«ææ—¶é—´ï¼Œæ‰§è¡Œæ‰«æ
                if time_until_next_scan == 0:
                    success = self.perform_scan()
                    if not success:
                        # æ‰«æå¤±è´¥ï¼ŒæŒ‡æ•°é€€é¿é‡è¯•
                        self.retry_count += 1
                        if self.retry_count >= self.max_retries:
                            self.log_message("âŒ é‡è¯•æ¬¡æ•°è¾¾åˆ°ä¸Šé™ï¼Œåœæ­¢ç›‘æ§")
                            self.after(0, self.stop_monitoring)
                            return
                        
                        # è®¡ç®—é‡è¯•å»¶è¿Ÿï¼ˆæŒ‡æ•°é€€é¿ï¼‰
                        retry_delay = min(self.retry_delay_base * (2 ** (self.retry_count - 1)), 300)  # æœ€å¤§5åˆ†é’Ÿ
                        self.log_message(f"ğŸ”„ {retry_delay}ç§’åé‡è¯• (ç¬¬{self.retry_count}æ¬¡)")
                        
                        # ç­‰å¾…é‡è¯•
                        for _ in range(int(retry_delay)):
                            if self.should_stop or not self.is_monitoring:
                                break
                            if self.force_check_event.is_set():
                                self.force_check_event.clear()
                                break
                            time.sleep(1)
                        continue
                
                # ç­‰å¾…ä¸‹ä¸€æ¬¡æ‰«ææˆ–å¼ºåˆ¶æ£€æŸ¥
                wait_interval = min(time_until_next_scan, 1)  # æœ€å¤šç­‰å¾…1ç§’å†æ£€æŸ¥
                for _ in range(int(wait_interval * 10)):  # æ¯0.1ç§’æ£€æŸ¥ä¸€æ¬¡
                    if self.should_stop or not self.is_monitoring:
                        break
                    if self.force_check_event.is_set():
                        self.force_check_event.clear()
                        break
                    time.sleep(0.1)
                    
            except Exception as e:
                self.log_message(f"âŒ ç›‘æ§å¾ªç¯é”™è¯¯: {e}")
                logger.error(f"ç›‘æ§å¾ªç¯é”™è¯¯è¯¦ç»†ä¿¡æ¯: {traceback.format_exc()}")
                
                # ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡è¯•
                for _ in range(10):
                    if self.should_stop or not self.is_monitoring:
                        break
                    time.sleep(1)
        
        # ç›‘æ§ç»“æŸï¼Œæ–­å¼€è¿æ¥
        try:
            self.connection_manager.disconnect()
        except Exception as e:
            self.log_message(f"âš ï¸ æ–­å¼€è¿æ¥æ—¶å‡ºé”™: {e}")
        self.update_connection_status()
        self.log_message("ğŸ”š ç›‘æ§å¾ªç¯ç»“æŸ")

class EmailMonitorApp(tk.Tk):
    """åº”ç”¨ä¸»ç±»ï¼Œç®¡ç†ç•Œé¢åˆ‡æ¢"""
    def __init__(self):
        super().__init__()
        self.title("ä¼ä¸šé‚®ç®±ç›‘æ§ç³»ç»Ÿ v2.0")
        self.geometry("1200x800")
        self.minsize(1000, 600)
        self.center_window()
        self.style = ttk.Style(self)
        self.style.theme_use("clam")
        self.container = ttk.Frame(self)
        self.container.pack(fill=tk.BOTH, expand=True)
        self.container.grid_rowconfigure(0, weight=1)
        self.container.grid_columnconfigure(0, weight=1)
        self.frames = {}
        self._create_frames()
        self.show_login_frame()

    def center_window(self):
        """çª—å£å±…ä¸­"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')

    def _create_frames(self):
        """åˆ›å»ºæ‰€æœ‰æ¡†æ¶"""
        # åªåˆ›å»ºLoginFrameï¼ŒMainFrameä¼šåœ¨éœ€è¦æ—¶åŠ¨æ€åˆ›å»º
        frame = LoginFrame(self.container, self)
        self.frames[LoginFrame] = frame
        frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

    def show_login_frame(self):
        """æ˜¾ç¤ºç™»å½•ç•Œé¢"""
        # å¦‚æœå­˜åœ¨MainFrameï¼Œåˆ™é”€æ¯å®ƒ
        if hasattr(self, 'main_frame') and self.main_frame:
            try:
                self.main_frame.stop_monitoring()
                self.main_frame.stop_file_watchers()
                # æ·»åŠ å¼‚å¸¸å¤„ç†
                try:
                    self.main_frame.connection_manager.disconnect()
                except Exception as e:
                    logger.error(f"æ–­å¼€è¿æ¥å¤±è´¥: {e}")
            except Exception as e:
                logger.error(f"åœæ­¢ç›‘æ§å¤±è´¥: {e}")
            finally:
                # ç¡®ä¿é”€æ¯
                self.main_frame.destroy()
                self.main_frame = None
        
        # æ˜¾ç¤ºç™»å½•ç•Œé¢
        frame = self.frames[LoginFrame]
        frame.tkraise()
        self.title("ä¼ä¸šé‚®ç®±ç›‘æ§ç³»ç»Ÿ - ç™»å½•")

    def show_main_frame(self, **kwargs):
        """æ˜¾ç¤ºä¸»ç›‘æ§ç•Œé¢"""
        # åˆ›å»ºMainFrameå¹¶ä¼ é€’å‚æ•°
        self.main_frame = MainFrame(self.container, self, **kwargs)
        self.main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        self.main_frame.tkraise()
        self.title("ä¼ä¸šé‚®ç®±ç›‘æ§ç³»ç»Ÿ - ç›‘æ§é¢æ¿")

    def on_closing(self):
        """å…³é—­åº”ç”¨æ—¶çš„å¤„ç†"""
        if hasattr(self, 'main_frame') and self.main_frame:
            try:
                self.main_frame.stop_monitoring()
                self.main_frame.stop_file_watchers()
                self.main_frame.connection_manager.disconnect()
            except Exception as e:
                logger.error(f"å…³é—­åº”ç”¨æ—¶å‡ºé”™: {e}")
        self.destroy()

if __name__ == "__main__":
    try:
        app = EmailMonitorApp()
        app.protocol("WM_DELETE_WINDOW", app.on_closing)
        app.mainloop()
    except Exception as e:
        logger.critical(f"åº”ç”¨å¯åŠ¨å¤±è´¥: {e}")
        messagebox.showerror("è‡´å‘½é”™è¯¯", f"åº”ç”¨å¯åŠ¨å¤±è´¥: {e}")
